
Learn PYTHON the HARD WAY

ex0
    本书主要介绍的其实是一种编程语言的学习方法。主要的思路是，对于一门编程语言，先从简单的程序代码入手，把一个代码块作为练习对象（ex），在了解理论知识之前，首先应该把代码段输入到机器中，编译并运行，观察结果，再而通过书本，对代码进行理论知识的学习，当然，对于不能理解的代码，建议通过互联网，以代码为关键字在搜索引擎中进行相关搜索。并在程序上做注释，记下笔记。在这个练习（ex）的基础上，继续深入一点，把下一个知识点，或者是在之前的练习的基础上，加入新的代码，作为下一个练习（ex）进行学习。如此往复。在多轮的练习后，把笔记总结到一个文档中，是对之前一段时间的学习总结，也方便日后进行复习和翻查。因此，也就产生了这份读书笔记。

ex1
1.  本书建议，python脚本的练习内容最好写在一个文件中，并命名为.py格式，然后在命令行中运行，如：python ex01.py。（如果用的是python3，则：python3 ex01.py）。在Linux系统中，命令行一般用的shell，而在Windows系统中，可以在运行中输入powershell来打开powershell。当然，有一些书是推荐在IDLE上进行学习实验，但不利于整个脚本程序的运行，因此本书不推荐。
2.  在python脚本文件中，若要提供对中文的支持，必须在第一行加入“# -*- coding: utf-8 -*-”，来告诉编辑器提供对中文输入输出的编码设置。
3.  python用#后可跟单行注释。而一个包含多行的字符串被三引号（'''）括起，但不赋给一个变量的时候，这个被三引号括起的字符串也会被视为注释。
4.  python内置70+个内建函数（BIF,built-in-function）。其中用来把字符打印到屏幕上的是print，用法举例：
    print list  # 打印一个列表    
                # 而在python3中，需要这样：print (list)
    print "%s" % stringLine  # 以格式化方式输出变量stringLine中的字符串
                             # 而在python3中，需要这样：print ("%s" % stringLine)
5.  一般情况下，print在在印完一行后，会自动换行，如果想在打印完一行后不换行，
    在python2中，要这样：print list,
    在python3中，要这样：print (list, end = ' ')
6.  遇到错误信息can't open file 'ex1.py':[Errno2]No such file or directory，一般是因为在错误的目录下执行脚本，又或者该创建的文件还没被创建。


ex2
1.  关于单行注释符号#，其实我更喜欢把它读成sharp。
2.  在双引号中的#后的字符，如：print "Hi,# jack"，并没被视为注释，只是被看作普通字符对待。
3.  关于多行注释，其实可以用三引号（''')，如：
'''something
something
something'''
    不过本书建议，用多个#进行多行注释。
4.  在程序遇到理解不了的语句，在初学阶段检查不明bug时，可尝试倒着看代码，这是个不错的查错技巧。

ex3
1.  python的数学符号：+，-，*，/，%，<，<=，>，>=，!=，==等等
2.  关于运算的优先级，在美国用PEMDAS来辅助记忆，括号（Parentheses），指数（Exponents），乘（Multiplication），除（Division），加（Addition），减（Subtraction）。
3.  如果是7/4，由于是整形，小数被丢弃了，所以结果是1，如果想进行小数的计算，必须把操作数转换为浮点数，如7.0/4.0。在整形的除法运算中，不管小数部分是大于等于0.5还是小于0.5，结果都只会直接丢弃小数部分，而不会进行四舍五入。

ex4
1.  关于变量，python不需要对变量进行声明，只要直接把内容赋值就能直接创建变量。但，要注意数据类型，必要时可利用int()和float()之类的BIF对数据进行强制类型转换。
2.  初学者对于赋值符号（=）和关系符号（==）有时会难以理解。赋值符号一般用于创建一个变量（当然，这是针对python来说，在c/c++之类的语言中，变量一般通过声明来创建的），也就是本书中所说的给一堆字符串，给一个符号或者给一个数值起个名字。而关系符号，是用来判断左右两边的表达式是否相等，相等的时候是真，不相等的时候是假，是一个判断真假的条件。
3.  本书建议，在赋值符号两旁加上空格，让代码更容易阅读，如：x = 100

ex5
1.  关于格式化打印，常用到的是%s、%d还有%r。%r是非常有用的一个，意思是不管什么都打印，一般用于程序调试，打印出来的是程序员写到里面的原始字符，包括转义字符‘\’
2.  round()函数是一个BIF，用于对浮点数进行四舍五入，如：round(1.7333)。

ex6
1.  对于一个布尔值，在程序中可以像这样来创建：hilarious = False    valEqui = True
2.  关于字符串，字符串可以用单引号（''）括起来，或者用双引号（""）括起来后赋给一个变量进行创建。在变量中，创建变量时用到的外围单/双引号是不包含在变量里面的。但在python2中，如果要在print中打印单引号但又不想用转移字符，那就可以这样：print "'AAA'"，双引号的话：print '"AAA"'。本书所说到用这两种方法其实并没什么不同。
3.  在提示TypeError:not all arguments converted during string formatting的时候，很可能是因为%的格式化字符数量比后面给的变量要多。

ex7
1.  格式化打印可以这样：print "good %s" % 'morning'
2.  多个变量的格式化打印，可以这样：
    a = apple
    b = boy
    c = cat
    print a + b + c
    也可以这样：
    print "%s %s %s" %(a,b,c)
    当然，以上是python2中的代码方式，python3中请务必在print后加上括号，例如：print ("%s %s %s" % (a, b, c))
3.  要是在写print的代码时，要是一行的字数超过80个，可以用“\”进行换行，换行后，第二行从第一个字符开始接驳到第一行的“\位置”。

ex8
1.  在print中，双引号中可以直接打印打印号，单引号中也可以直接打印双引号，但要是双引号里面要打印双引号，就必须运用转义字符“\”了。

ex9
1.  三引号（'''）可以用来括起多行的字符串，当然，真正输出的第二行是从三引号的第二行的第一个字符开始，并不会忽略字符前的空格。

ex10
1.  python中的转义字符，其实和C差不多，就不写笔记了。（懒）不过要重点注意的是，转义字符用的是反斜杠“\”，斜杠和反斜杠其实很容易记，就是一个表情“/_\”。

2.  在print中，如果使用了格式化输出%r，转义字符将会不好使，因为%r是会直接打印出原始字符，其中包括转义字符的“\”。

ex11
1.  从终端接受用户输入，可以用raw_input()这个BIF。用法是：var = raw_input()，当然还可以这样var = raw_input('>')，这样就时在一个提示符后进行输入了。
2.  以前的python用的是input()，但本书建议，从终端获取输入最好就是用raw_input()，不要使用input()。

ex12
1.  运用pydoc命令可以查看BIF的用法，例如：pydoc raw_input，就能查看raw_input这个函数的用法了。

ex13
1.  在python脚本中引入命令行参数，要在文件头部加上from sys import argv，意思是从sys库中导入argv模块。我也试过直接import sys，活着import argv，结果报错了。
2.  在导入了模块之后，可以这样对命令行参数进行解包：script, var = argv，这样，第一个参数就以字符串方式被丢到var中了，当然，script变量中存放的是程序的名字。
3.  以上的解包方式，参数的数量是被确定好的，如果参数的数量和解包的数量对不上，就会报错。
4.  关于argv和raw_input的区别，argv是在命令行启动程序的时候，把参数同时传入程序中。而raw_input是程序开始以后，在程序运行的途中由用户通过终端输入的数据。
5.  而相对于C语言的argc和argv，python也是可以取类似的值,为了启动这个功能，必须先import sys。
    若要取argc，可以这样：   argc = len(sys.argv)
    若要取argv[0]，可以这样：argv_0 = sys.argv[0]
6.  python也支持命令行选项，函数原型是getopt.getopt(args,options[,long_options])，在使用该函数前，必须先import sys,getopt，然后可执行类似以下的代码：

opts, args = getopt.getopt(sys.argv[1:],"hi:o:")
input_file = ""
output_file = ""
for op, value in opts:
    if op == "-i":
        input_file = value
    elif op == "-o":
        output_file = value
    elif op == "-h":
        usage()
        sys.exit()

a) sys.argv[1:]为要处理的参数列表，sys.argv[0]为脚本名，所以用sys.argv[1:]过滤掉脚本名。
b) "hi:o:": 当一个选项只是表示开关状态时，即后面不带附加参数时，在分析串中写入选项字符。当选项后面是带一个附加参数时，在分析串中写入选项字符同时后面加一个":"号。所以"hi:o:"就表示"h"是一个开关选项；"i:"和"o:"则表示后面应该带一个参数。
c) 调用getopt函数。函数返回两个列表：opts和args。opts为分析出的格式信息。args为不属于格式信息的剩余的命令行参数。opts是一个两元组的列表。每个元素为：(选项串,附加参数)。如果没有附加参数则为空串''。

getopt函数的第三个参数[, long_options]为可选的长选项参数，上面例子中的都为短选项(如-i -o)
长选项格式举例:
--version
--file=error.txt
让一个脚本同时支持短选项和长选项
getopt.getopt(sys.argv[1:], "hi:o:", ["version", "file="])

7.  对于命令行的参数输入，参数被解析为字符串，所以，如果要把参数用于数学计算，必须先给参数做强制类型装换，用int()或者float()之类。

ex14
1.  可以把用户输入提示符赋给一个变量，如：prompt = '>'，然后var = raw_input(prompt)，从而避免提示符的重复输入或者更改
2.  本练习建议读者玩一下早期的两款文字冒险游戏，分别是：Zork和Adventure。

ex15
1.  在IDLE中输入：dir(__builtins__)，注意是双下划线，就能查到所有的BIF。
2.  想要打开文件，可以这样：file = open(filename)，括号中的filename应该是一个字符串，而且这样只能打开一个文件，但如果文件不存在，则会报错。
3.  想要读取文件中的所有内容，可以这样：somethingInFile = file.read()。这里的file.read中的file用的是open()返回后的变量名。
4.  一般情况下，我会把XXX.YYY()中的YYY称为方法，而把ZZZ()称为函数，嘛，其实都一样。

ex16
1.  也可以这样，file = open(filename, 'w')，filename是一个字符串，而'w'的作用是，如果文件存在了，就打开文件并清空，如果文件不存在，则创建文件并打开。
2.  somethingInFile = file.read()，是用来读取文件的所有内容。
3.  oneLine = file.readline()，是用来读取文件中的一行的数据，也就是从seek指针的字符到下一个'\n'位置的内容，然后返回给一个变量保存。
4.  file.truncate()，可以用来清空文件的内容，当然，如果以'w'方式打开的文件，就没必要用这个方法了。
5.  file.write(something)，是用来把something的字符串写入到一个文件中。
6.  在完成对一个文件的操作之后，需要这样：file.close()关闭文件，否则会一直占用系统资源。
7.  另外，除了可以以‘写入’方式'w'打开文件以外，还可以是‘只读read’方式'r'打开，还可以以‘追加append’方式'a'打开

ex17
1.  len()这个BIF，如果括号里面是一个列表，则返回列表的个数，但如果里面放的是一个字符串，则会返回字符串的字符个数。
2.  exists()的作用是检查文件是否存在，若存在，则返回True，不存在就返回False。
3.  这么一行代码：indata = open(from_file).read()，在文件被读完并赋值给indata之后，python就会自动关闭文件，因此就不需要close()方法了。

ex18
1.  用def命令创建一个函数，想下面这样：
def nameFuntion(var):
    #some codes be run
    def后面是函数名，然后是括号，括号里面是函数的形参，括号右边是一个“:”，下一行要进行四格的缩进。python的函数体定义是以缩进相同格数来测定函数域的范围。
2.  函数名和变量名一样，由字母、下划线和数字组成，且不以数字开头。
3.  可以在形参中定义*args，把参数作为字符串都接收起来，并在函数体里解包，像这样：
def nameFun(*args):
    arg1, arg2 = *args

ex19
1.  print "something" ，这么一个print在打印完之后，会自动换行。
2.  关于变量的作用域，一般是在函数体的当前域，因为python不像C那样在main外面定义全局变量，因此无法像C那样在函数中修改全局变量。
    在函数中，也无法修改定义在这函数外面的变量，只能通过返回值影响函数外变量。

ex20
1.  通过函数file.seek(0)方法，可以对文件指针进行设定，修改其位置。因为每次运行类似file.readline()的方法，都会修改文件指针。
2.  x += y，可以理解为x = x + y。

ex21
1.  在函数最后用return，可返回值。
2.  强制类型转换int()和输入raw_input()可以混合使用，如：int(raw_input())，或者float(raw_input())。

ex24
1.  同一个函数中可以同时返回三个变量，并丢给上层函数的三个变量。如：beans, jars, crates = secret_formula(start_point)
2.  也可以在print中格式化输出三个返回值，如：print "%s, %s, %s" % secret_formula(start_point)

ex25
1.  split()方法是用来对一个字符串用某个符号进行分割，并产生一个列表，假如stuff是一个字符串，可以这样：words = stuff.split(' ')。
2.  sorted()是一个BIF，用于对一个列表进行排序，例如：sorted(words)
3.  pop()方法是用来弹出（删除）一个列表最末尾的那个元素，然后返回被弹出的元素。例如：newWords = words.pop()
4.  在python中，可以通过导入一个模块来使用模块中的函数。例如现在有一个模块ex25.py，可以在同一文件夹下的另一个文件中import ex25来使用ex25中定义的函数。
    假如，ex25.py仲有一个函数是printWord()，在同一目录下的另一个文件中可以先import ex25，然后ex25.printWord()。
5.  在定义一个函数的时候，在函数名的下面，函数体的上面空白行用"""括起的字符串，成为文档注释，在IDLE中import该模块后，可以输入help(ex25)查看这些文档注释。
6.  pop()方法还可以用来弹出列表中指定位置的元素，返回的是被弹出的那个元素，例如：newWords = words.pop(0)

ex27
1.  关于真值表，需要牢记

ex28
1.  关于布尔值，真为True，假为False。
2.  而，"test" and "test" 会返回"test"， 1 and 1 返回 1，"test" and 1 返回 1，这很奇怪。
3.  != 和 <>除了写法不同，用法是一样的，不过!=用得比较多。
4.  python同样存在短路逻辑。

ex29
1.  if语句是先进行条件判断，若为真，则执行，为假，则跳过。作用域和函数的定义相同，也是用相同的缩进格式来判定作用域的范围。例如：
if a>b:
    return a
else:
    return b
2.  如果不缩进，程序将报错。
3.  x += 1 和 x = x + 1一样，y -= 5 和 y = y - 5 一样，如此类推。

ex30
1.  if条件不为真，再判断elif条件是否为真，不为真，则执行else。
2.  如果多个elif都为真，则只执行第一个elif的块。
3.  range()这个BIF是用于生成指定范围列表，例如：range(6)，是用来生成1~5的列表，不包含6；range(1,6)生成1~5的列表，range(1，5，2)生成1~4间隔2的列表。

ex31
1.  append()方法可以在列表最后追加元素，例如：newList.append(i)
2.  列表中的列表和二维数组的原理差不多，但使用起来比二维数组更方便。
3.  在for循环开始时的循环变量是一个局部变量。
4.  通过raw_input('>')输入的是字符串。
5.  for循环的用法，是这样的：
for i in newList:
    print "%r" % i

ex32















































